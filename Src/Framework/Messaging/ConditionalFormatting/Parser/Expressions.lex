namespace Trx.Messaging.ConditionalFormatting {

using System;

/*
 * This file was generated by C#Lex, after doing that you must:
 *
 * 	1. Add a '}' at the end of the generated file because C#Lex doesn't
 *	   allow to specify correctly a namespace.
 *
 *	2. Delete the second implementation of yy_advance() function.
 *	3. Remove yy_eof_done and yy_last_was_cr variables to make the compiler happy :)
 */
%%
%unicode
%ignorecase
%public
%class LexicalAnalyzer

%{
	//private IdentificatorFactory _identificatorFactory = null;
	private int _currentTokenIndex = 0;
	private int _lastRead = 0;

	internal int CurrentTokenIndex {

		get {

			return _currentTokenIndex + yy_buffer_start + 1;
		}
	}

	// This yy_advance() function must remain.
	private int yy_advance() {
		int next_read;
		int i;
		int j;
		if (yy_buffer_index < yy_buffer_read) {
			return yy_buffer[yy_buffer_index++];
		}
		if (0 != yy_buffer_start) {
			i = yy_buffer_start;
			j = 0;
			while (i < yy_buffer_read) {
				yy_buffer[j] = yy_buffer[i];
				++i;
				++j;
			}
			yy_buffer_end = yy_buffer_end - yy_buffer_start;
			yy_buffer_start = 0;
			yy_buffer_read = j;
			yy_buffer_index = j;
			next_read = yy_reader.Read(yy_buffer,
				yy_buffer_read,
				yy_buffer.Length - yy_buffer_read);
			if ( 0 == next_read) {
				if ( yy_buffer_end > 0) {
					_currentTokenIndex += _lastRead - yy_buffer_end;
				}
				_lastRead = 0;
				return YY_EOF;
			}
			_currentTokenIndex += _lastRead;
			_lastRead = next_read;
			yy_buffer_read = yy_buffer_read + next_read;
		}
		while (yy_buffer_index >= yy_buffer_read) {
			if (yy_buffer_index >= yy_buffer.Length) {
				yy_buffer = yy_double(yy_buffer);
			}
			next_read = yy_reader.Read(yy_buffer,
				yy_buffer_read,
				yy_buffer.Length - yy_buffer_read);
			if ( 0 == next_read) {
				return YY_EOF;
			}
			_currentTokenIndex += _lastRead;
			_lastRead = next_read;
			yy_buffer_read = yy_buffer_read + next_read;
		}
		return yy_buffer[yy_buffer_index++];
	}
%}

Digit=[0-9]
HexadecimalDigit=[0-9a-fA-F]
Letter=[a-zA-Z]
IdentificatorSeparator="."
StringDelimiter="'"
StringCharacter=[^{StringDelimiter}]
Fillers=[ \t\r\n\f]

StringConstant={StringDelimiter}({StringCharacter})*{StringDelimiter}
BinaryConstant={HexadecimalDigit}+[hH]

Parent=[Pp][Aa][Rr][Ee][Nn][Tt]
Natural={Digit}+
Mti=[Mm][Tt][Ii]
IsSet=[Ii][Ss][Ss][Ee][Tt]

Or=[Oo][Rr]
And=[Aa][Nn][Dd]
Not=[Nn][Oo][Tt]

Identificator={Letter}({Digit}|{Letter}|"_")*({IdentificatorSeparator}{Letter}({Digit}|{Letter}|"_")*)*

%%

{Or}				{
						return new Yytoken( Token.Or, CurrentTokenIndex );
					}
{And}				{
						return new Yytoken( Token.And, CurrentTokenIndex );
					}
{Not}				{
						return new Yytoken( Token.Not, CurrentTokenIndex );
					}
"("					{
						return new Yytoken( Token.LeftParenthesis, CurrentTokenIndex );
					}
")"					{
						return new Yytoken( Token.RightParenthesis, CurrentTokenIndex );
					}
"["					{
						return new Yytoken( Token.LeftSquareBracket, CurrentTokenIndex );
					}
"]"					{
						return new Yytoken( Token.RightSquareBracket, CurrentTokenIndex );
					}
"="					{
						return new Yytoken( Token.EqualsOperator, CurrentTokenIndex );
					}
"."					{
						return new Yytoken( Token.IdentificatorSeparator, CurrentTokenIndex );
					}
","					{
						return new Yytoken( Token.ParameterSeparator, CurrentTokenIndex );
					}
{Natural}			{
						return new Yytoken( Token.Natural, CurrentTokenIndex, Convert.ToInt32( yytext() ) );
					}
{Parent}			{
						return new Yytoken( Token.Parent, CurrentTokenIndex );
					}
{Mti}				{
						return new Yytoken( Token.Mti, CurrentTokenIndex );
					}
{IsSet}				{
						return new Yytoken( Token.IsSet, CurrentTokenIndex );
					}
{StringConstant}	{
						return new Yytoken( Token.StringConstant, CurrentTokenIndex,
							new StringConstantExpression( yytext().Substring( 1, yytext().Length - 2 ) ) );
					}
{BinaryConstant}	{
						return new Yytoken( Token.BinaryConstant, CurrentTokenIndex,
							new BinaryConstantExpression( yytext().Substring( 0, yytext().Length - 1 ) ) );
					}
{Fillers}			{
						/* Ignore fillers. */break;
					}
.					{
						return new Yytoken( Token.Error, CurrentTokenIndex,
							"Illegal character: " + yytext());
					}